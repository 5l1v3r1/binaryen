  /*
   * Copyright 2020 WebAssembly Community Group participants
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  //=============================================================================
  // This is an AUTOGENERATED file, even though it looks human-readable! Do not
  // edit it by hand, instead edit what it is generated from. You can and should
  // treat it like human-written code in all other ways, though, like reviewing
  // it in a PR, etc.
  //=============================================================================

case Expression::NopId: {
  break;
}
case Expression::BlockId: {
  if (left->name.is() != right.name.is()) {
    return false;
  }
  rightNames[left->name] = right->name;
  if (left->list.size() != right.list.size()) {
    return false;
  }
  for (auto* child : left->list) {
    leftStack.push_back(child);
  }
  for (auto* child : right->list) {
    rightStack.push_back(child);
  }
  break;
}
case Expression::IfId: {
  leftStack.push_back(left->condition);
  rightStack.push_back(right->condition);
  leftStack.push_back(left->ifTrue);
  rightStack.push_back(right->ifTrue);
  leftStack.push_back(left->ifFalse);
  rightStack.push_back(right->ifFalse);
  break;
}
case Expression::LoopId: {
  if (left->name.is() != right.name.is()) {
    return false;
  }
  rightNames[left->name] = right->name;
  leftStack.push_back(left->body);
  rightStack.push_back(right->body);
  break;
}
case Expression::BreakId: {
  if (rightNames[left->name] != right->name) {
    return false;
  }
  leftStack.push_back(left->value);
  rightStack.push_back(right->value);
  leftStack.push_back(left->condition);
  rightStack.push_back(right->condition);
  break;
}
case Expression::SwitchId: {
  if (left->targets.size() != right->targets.size()) {
    return false;
  }
  for (Index i = 0; i < left->targets.size(); i++) {
    if (rightNames[left->targets[i]] != right->targets[i]) {
      return false;
    }
  }
  if (rightNames[left->default_] != right->default_) {
    return false;
  }
  leftStack.push_back(left->condition);
  rightStack.push_back(right->condition);
  leftStack.push_back(left->value);
  rightStack.push_back(right->value);
  break;
}
case Expression::CallId: {
  if (left->operands.size() != right.operands.size()) {
    return false;
  }
  for (auto* child : left->operands) {
    leftStack.push_back(child);
  }
  for (auto* child : right->operands) {
    rightStack.push_back(child);
  }
  if (left->target != right->target) {
    return false;
  }
  if (left->isReturn != right->isReturn) {
    return false;
  }
  break;
}
case Expression::CallIndirectId: {
  if (left->sig != right->sig) {
    return false;
  }
  if (left->operands.size() != right.operands.size()) {
    return false;
  }
  for (auto* child : left->operands) {
    leftStack.push_back(child);
  }
  for (auto* child : right->operands) {
    rightStack.push_back(child);
  }
  leftStack.push_back(left->target);
  rightStack.push_back(right->target);
  if (left->isReturn != right->isReturn) {
    return false;
  }
  break;
}
case Expression::LocalGetId: {
  if (left->index != right->index) {
    return false;
  }
  break;
}
case Expression::LocalSetId: {
  if (left->index != right->index) {
    return false;
  }
  leftStack.push_back(left->value);
  rightStack.push_back(right->value);
  break;
}
case Expression::GlobalGetId: {
  if (left->name != right->name) {
    return false;
  }
  break;
}
case Expression::GlobalSetId: {
  if (left->name != right->name) {
    return false;
  }
  leftStack.push_back(left->value);
  rightStack.push_back(right->value);
  break;
}
case Expression::LoadId: {
  if (left->bytes != right->bytes) {
    return false;
  }
  if (LoadUtils::isSignRelevant(left)) {
    if (left->signed_ != right->signed_) {
      return false;
    }
  }
  if (left->offset != right->offset) {
    return false;
  }
  if (left->align != right->align) {
    return false;
  }
  if (left->isAtomic != right->isAtomic) {
    return false;
  }
  leftStack.push_back(left->ptr);
  rightStack.push_back(right->ptr);
  break;
}
case Expression::StoreId: {
  if (left->bytes != right->bytes) {
    return false;
  }
  if (left->offset != right->offset) {
    return false;
  }
  if (left->align != right->align) {
    return false;
  }
  if (left->isAtomic != right->isAtomic) {
    return false;
  }
  leftStack.push_back(left->ptr);
  rightStack.push_back(right->ptr);
  leftStack.push_back(left->value);
  rightStack.push_back(right->value);
  if (left->valueType != right->valueType) {
    return false;
  }
  break;
}
case Expression::AtomicRMWId: {
  if (left->op != right->op) {
    return false;
  }
  if (left->bytes != right->bytes) {
    return false;
  }
  if (left->offset != right->offset) {
    return false;
  }
  leftStack.push_back(left->ptr);
  rightStack.push_back(right->ptr);
  leftStack.push_back(left->value);
  rightStack.push_back(right->value);
  break;
}
case Expression::AtomicCmpxchgId: {
  if (left->bytes != right->bytes) {
    return false;
  }
  if (left->offset != right->offset) {
    return false;
  }
  leftStack.push_back(left->ptr);
  rightStack.push_back(right->ptr);
  leftStack.push_back(left->expected);
  rightStack.push_back(right->expected);
  leftStack.push_back(left->replacement);
  rightStack.push_back(right->replacement);
  break;
}
case Expression::AtomicWaitId: {
  if (left->offset != right->offset) {
    return false;
  }
  leftStack.push_back(left->ptr);
  rightStack.push_back(right->ptr);
  leftStack.push_back(left->expected);
  rightStack.push_back(right->expected);
  leftStack.push_back(left->timeout);
  rightStack.push_back(right->timeout);
  if (left->expectedType != right->expectedType) {
    return false;
  }
  break;
}
case Expression::AtomicNotifyId: {
  if (left->offset != right->offset) {
    return false;
  }
  leftStack.push_back(left->ptr);
  rightStack.push_back(right->ptr);
  leftStack.push_back(left->notifyCount);
  rightStack.push_back(right->notifyCount);
  break;
}
case Expression::AtomicFenceId: {
  if (left->order != right->order) {
    return false;
  }
  break;
}
case Expression::SIMDExtractId: {
  if (left->op != right->op) {
    return false;
  }
  leftStack.push_back(left->vec);
  rightStack.push_back(right->vec);
  if (left->index != right->index) {
    return false;
  }
  break;
}
case Expression::SIMDReplaceId: {
  if (left->op != right->op) {
    return false;
  }
  leftStack.push_back(left->vec);
  rightStack.push_back(right->vec);
  if (left->index != right->index) {
    return false;
  }
  leftStack.push_back(left->value);
  rightStack.push_back(right->value);
  break;
}
case Expression::SIMDShuffleId: {
  leftStack.push_back(left->left);
  rightStack.push_back(right->left);
  leftStack.push_back(left->right);
  rightStack.push_back(right->right);
  if (left->mask != right->mask) {
    return false;
  }
  break;
}
case Expression::SIMDTernaryId: {
  if (left->op != right->op) {
    return false;
  }
  leftStack.push_back(left->a);
  rightStack.push_back(right->a);
  leftStack.push_back(left->b);
  rightStack.push_back(right->b);
  leftStack.push_back(left->c);
  rightStack.push_back(right->c);
  break;
}
case Expression::SIMDShiftId: {
  if (left->op != right->op) {
    return false;
  }
  leftStack.push_back(left->vec);
  rightStack.push_back(right->vec);
  leftStack.push_back(left->shift);
  rightStack.push_back(right->shift);
  break;
}
case Expression::SIMDLoadId: {
  if (left->op != right->op) {
    return false;
  }
  if (left->offset != right->offset) {
    return false;
  }
  if (left->align != right->align) {
    return false;
  }
  leftStack.push_back(left->ptr);
  rightStack.push_back(right->ptr);
  break;
}
case Expression::MemoryInitId: {
  if (left->segment != right->segment) {
    return false;
  }
  leftStack.push_back(left->dest);
  rightStack.push_back(right->dest);
  leftStack.push_back(left->offset);
  rightStack.push_back(right->offset);
  leftStack.push_back(left->size);
  rightStack.push_back(right->size);
  break;
}
case Expression::DataDropId: {
  if (left->segment != right->segment) {
    return false;
  }
  break;
}
case Expression::MemoryCopyId: {
  leftStack.push_back(left->dest);
  rightStack.push_back(right->dest);
  leftStack.push_back(left->source);
  rightStack.push_back(right->source);
  leftStack.push_back(left->size);
  rightStack.push_back(right->size);
  break;
}
case Expression::MemoryFillId: {
  leftStack.push_back(left->dest);
  rightStack.push_back(right->dest);
  leftStack.push_back(left->value);
  rightStack.push_back(right->value);
  leftStack.push_back(left->size);
  rightStack.push_back(right->size);
  break;
}
case Expression::ConstId: {
  if (left->value != right->value) {
    return false;
  }
  break;
}
case Expression::UnaryId: {
  if (left->op != right->op) {
    return false;
  }
  leftStack.push_back(left->value);
  rightStack.push_back(right->value);
  break;
}
case Expression::BinaryId: {
  if (left->op != right->op) {
    return false;
  }
  leftStack.push_back(left->left);
  rightStack.push_back(right->left);
  leftStack.push_back(left->right);
  rightStack.push_back(right->right);
  break;
}
case Expression::SelectId: {
  leftStack.push_back(left->ifTrue);
  rightStack.push_back(right->ifTrue);
  leftStack.push_back(left->ifFalse);
  rightStack.push_back(right->ifFalse);
  leftStack.push_back(left->condition);
  rightStack.push_back(right->condition);
  break;
}
case Expression::DropId: {
  leftStack.push_back(left->value);
  rightStack.push_back(right->value);
  break;
}
case Expression::ReturnId: {
  leftStack.push_back(left->value);
  rightStack.push_back(right->value);
  break;
}
case Expression::MemorySizeId: {
  if (left->ptrType != right->ptrType) {
    return false;
  }
  break;
}
case Expression::MemoryGrowId: {
  leftStack.push_back(left->delta);
  rightStack.push_back(right->delta);
  if (left->ptrType != right->ptrType) {
    return false;
  }
  break;
}
case Expression::UnreachableId: {
  break;
}
case Expression::PopId: {
  break;
}
case Expression::RefNullId: {
  break;
}
case Expression::RefIsNullId: {
  leftStack.push_back(left->value);
  rightStack.push_back(right->value);
  break;
}
case Expression::RefFuncId: {
  if (left->func != right->func) {
    return false;
  }
  break;
}
case Expression::RefEqId: {
  leftStack.push_back(left->left);
  rightStack.push_back(right->left);
  leftStack.push_back(left->right);
  rightStack.push_back(right->right);
  break;
}
case Expression::TryId: {
  leftStack.push_back(left->body);
  rightStack.push_back(right->body);
  leftStack.push_back(left->catchBody);
  rightStack.push_back(right->catchBody);
  break;
}
case Expression::ThrowId: {
  if (left->event != right->event) {
    return false;
  }
  if (left->operands.size() != right.operands.size()) {
    return false;
  }
  for (auto* child : left->operands) {
    leftStack.push_back(child);
  }
  for (auto* child : right->operands) {
    rightStack.push_back(child);
  }
  break;
}
case Expression::RethrowId: {
  leftStack.push_back(left->exnref);
  rightStack.push_back(right->exnref);
  break;
}
case Expression::BrOnExnId: {
  if (rightNames[left->name] != right->name) {
    return false;
  }
  if (left->event != right->event) {
    return false;
  }
  leftStack.push_back(left->exnref);
  rightStack.push_back(right->exnref);
  if (left->sent != right->sent) {
    return false;
  }
  break;
}
case Expression::TupleMakeId: {
  if (left->operands.size() != right.operands.size()) {
    return false;
  }
  for (auto* child : left->operands) {
    leftStack.push_back(child);
  }
  for (auto* child : right->operands) {
    rightStack.push_back(child);
  }
  break;
}
case Expression::TupleExtractId: {
  leftStack.push_back(left->tuple);
  rightStack.push_back(right->tuple);
  if (left->index != right->index) {
    return false;
  }
  break;
}
case Expression::I31NewId: {
  leftStack.push_back(left->value);
  rightStack.push_back(right->value);
  break;
}
case Expression::I31GetId: {
  leftStack.push_back(left->i31);
  rightStack.push_back(right->i31);
  if (left->signed_ != right->signed_) {
    return false;
  }
  break;
}
case Expression::RefTestId: {
  break;
}
case Expression::RefCastId: {
  break;
}
case Expression::BrOnCastId: {
  break;
}
case Expression::RttCanonId: {
  break;
}
case Expression::RttSubId: {
  break;
}
case Expression::StructNewId: {
  break;
}
case Expression::StructGetId: {
  break;
}
case Expression::StructSetId: {
  break;
}
case Expression::ArrayNewId: {
  break;
}
case Expression::ArrayGetId: {
  break;
}
case Expression::ArraySetId: {
  break;
}
case Expression::ArrayLenId: {
  break;
}
